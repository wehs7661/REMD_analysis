import os
import sys
import subprocess
import argparse
import numpy as np 
import matplotlib.pyplot as plt 
from matplotlib import rc

def initialize():
    parser = argparse.ArgumentParser(
        description='This code analyzes the log file generated by replica \
                    exchange molecular dynamics (REMD) simulations and plot \
                    the trajectory of each replica as a function of time.')
    parser.add_argument('-l',
                        '--log',
                        type=str,
                        help='The file name of the log file.')
    parser.add_argument('-p',
                        '--prefix',
                        type=str,
                        help='The common prefix of the simulation files.')
    
    args_parse = parser.parse_args()

    return args_parse

class LogInfo:
    def __init__(self, logfile):
        """
        Gets the needed parameters and data from the log file and set up
        relevant attributes to run the analysis

        Parameters
        ----------
        logfile : str
            The filename of the log file
        """
        f = open(logfile, 'r')
        lines = f.readlines()
        f.close()

        self.nex = None
        self.N_states = None

        line_n = 0
        for l in lines:
            line_n += 1
            if 'Command line' in l:
                if 'nex' in lines[line_n + 1]:
                    self.nex = True
                else:
                    self.nex = False

            if 'Replica exchange in ' in l:
                self.N_states = len(lines[line_n].split())
            
            if 'Started mdrun' in l:
                self.start = line_n
                # the line number that the simulation got started
                break

            
class REMDAnalysis(LogInfo):
    """
    A class for state-time analysis of replica exchange molecular dynamics simulations. When
    instantiating this class, one parameter (logfile) is required.
    """

    def __init__(self, logfile):
        """
        Sets up the properties of the instance of EXEAnalysis
        """
        self.sample_all = None
        self.finish = None   # if the simulation finishes all the steps specified
        self.n_ex = 0        # number of exchanges
        LogInfo.__init__(self, logfile)

    def get_transition_matrix(self, logfile):
        """
        Gets the data of the transition matrix from the log file. Note that according 
        to the log file in GROMACS, index (i, j) in the transition matrix represents 
        the number of exchanges "BETWEEN SPOT i AND j" divided the total number of 
        exchanges.

        Parameters
        ----------
        logfile : str
            The name of the log file to read.

        Returns
        -------
        transition_matrix : np.array
            The transition matrix.
        """

        # Use external shell command to search the string would be faster
        try:
            subprocess.check_output("grep 'Replica exchange statistics' %s" % logfile, shell=True)
            self.finish = True
        except:
            # An error would occur if the string is not found
            self.finish = False

        f = open(logfile, 'r')
        lines = f.readlines()
        f.close()

        line_n = 0
        count_matrix = np.zeros([self.N_states, self.N_states])
        transition_matrix = np.zeros([self.N_states, self.N_states])

        if self.finish is True:
            # Then read from the bottom to get the overlap matrix
            # (since if the simulation is finished, the overlap matrix will be calculated automatically)
            lines.reverse()    # from this point, lines has been reverse
            for l in lines:
                # print(l)    # this will print from the bottom
                line_n += 1
                if 'Replica exchange statistics' in l:
                    # data starts from lines[line_n - 5]
                    for i in range(self.N_states):
                        transition_matrix[i] = [float(v) for v in lines[line_n - 5 - i].split('Repl')[1].split()[:self.N_states]]

        if self.finish is False:
            # Then we have to calculate overlap matrix on our own as follows.
            for l in lines[self.start:]:  # skip the metadata
                line_n += 1
                if 'Accepted Exchanges' in l:
                    self.n_ex += 1
                    rep_list =[int(i) for i in l.split(':')[1].split()]
                    for i in rep_list:
                        # Note that for the diagnal: count_matrix[i, i] += 2
                        count_matrix[i, rep_list.index(i)] += 1
                        count_matrix[rep_list.index(i), i] += 1

            # get transition_matrix from the data of count_matrix
            for i in range(self.N_states):
                for j in range(self.N_states):
                    transition_matrix[i, j] = count_matrix[i, j] / sum(count_matrix[i])

        return transition_matrix

    def plot_matrix(self, matrix, png_name):
        K = self.N_states
        index = range(K)
        fig = plt.figure(figsize=(K / 2 , K / 2))
        fig.add_subplot(111, frameon=False, xticks=[], yticks=[])

        for i in range(K):
            if i != 0:
                plt.vlines(x=i, ymin=0, ymax=K, lw=0.5, color='k', alpha=0.25)
                plt.hlines(y=i, xmin=0, xmax=K, lw=0.5, color='k', alpha=0.25)
            for j in range(K):
                if matrix[j, i] < 0.005:  
                    v = ''   # value to be shown 
                elif matrix[j, i] > 0.995:
                    v = '1.00'
                else:
                    v = ('%.2f' % matrix[j, i])[1:]
                alf = matrix[j, i] / (matrix.max())   # for controlling alpha values
                plt.fill_between([i, i + 1], [K - j, K -j], [K - (j + 1), K - (j + 1)], color='blue', alpha=alf) 
                
                # annotate the value of each element
                plt.annotate(v, xy=(i, j), xytext=(i + 0.5, K - (j + 0.5)), size=8, textcoords='data', va='center', ha='center', color=('k' if alf < 0.5 else 'w'))
                
            # labels of the state numbers
            plt.annotate(index[i], xy=(i + 0.5, 1), xytext=(i + 0.5, K + 0.5), size=10, textcoords=('data', 'data'), va='center', ha='center', color='k')
            plt.annotate(index[i], xy=(-0.5, K - (j + 0.5)), xytext=(-0.5, K - ( i + 0.5)), size=10, textcoords=('data', 'data'), va='center', ha='center', color='k')
        plt.annotate('$\lambda$', xy=(-0.5, K - (j + 0.5)), xytext=(-0.5, K + 0.5), size=14, textcoords=('data', 'data'), va='center', ha='center', color='k')

        # frame of the plot
        plt.plot([0, K], [0, 0], 'k-', lw=1.0, solid_capstyle='butt')
        plt.plot([K, K], [0, K], 'k-', lw=1.0, solid_capstyle='butt')
        plt.plot([0, 0], [0, K], 'k-', lw=1.0, solid_capstyle='butt')
        plt.plot([0, K], [K, K], 'k-', lw=1.0, solid_capstyle='butt')

        plt.xlim(0, K)
        plt.ylim(0, K)
        plt.annotate('Transition matrix', xy=(K / 2, K + 1.5), xytext=(K / 2, K + 1.8), size=10, weight='heavy', textcoords=('data', 'data'), va='center', ha='center', color='k')
        plt.axis('scaled')

        plt.savefig(png_name, dpi=600)
        plt.show()

    def get_state_time(self, logfile):
        pass




    def get_overlap_matrix():
        # this matrix can be obtained only if MBAR is used
        pass


        #f = open(log, 'r')
        #lines = f.readlines()
        #f.close()



def main():
    rc('font', **{
        'family': 'sans-serif',
        'sans-serif': ['DejaVu Sans'],
        'size': 10
    })
    # Set the font used for MathJax - more on this later
    rc('mathtext', **{'default': 'regular'})
    plt.rc('font', family='serif')

    args = initialize()

    if args.log is None:
        for file in os.listdir('.'):
            if file.endswith('.log'):
                args.log = file 
        if args.log is None:
            print('No log files provided or found! Please check if the dirctory is correct or specify the name of the log file.')
            sys.exit()

    if args.prefix is None:
        args.prefix = args.log.split('.')[0]

    RA = REMDAnalysis(args.log)
    t_matrix = RA.get_transition_matrix(args.log)
    RA.plot_matrix(t_matrix, 'transition_matrix_%s.png' % args.prefix)


        
