import os
import sys
import pymbar
import time as timer
import subprocess
import argparse
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
from matplotlib import cm


def initialize():
    parser = argparse.ArgumentParser(
        description='This code analyzes the log file generated by replica \
                    exchange molecular dynamics (REMD) simulations and plot \
                    the trajectory of each replica as a function of time.')
    parser.add_argument('-l',
                        '--log',
                        type=str,
                        help='The file name of the log file.')
    parser.add_argument('-p',
                        '--prefix',
                        type=str,
                        help='The common prefix of the simulation files.')

    args_parse = parser.parse_args()

    return args_parse


class LogInfo:
    def __init__(self, logfile):
        """
        Gets the needed parameters and data from the log file and set up
        relevant attributes to run the analysis

        Parameters
        ----------
        logfile : str
            The filename of the log file
        """
        f = open(logfile, 'r')
        lines = f.readlines()
        f.close()

        self.nex = None
        self.replex = None
        self.N_states = None
        self.dt = None

        line_n = 0
        for l in lines:
            line_n += 1

            if 'dt  ' in l and self.dt is None:
                self.dt = float(l.split('=')[1])

            if 'Command line' in l:
                if 'nex' in lines[line_n]:
                    self.nex = True
                else:
                    self.nex = False

                if 'replex' in lines[line_n]:
                    self.replex = float(lines[line_n].split('replex')[1].split()[0])

            if 'Replica exchange in ' in l:
                self.N_states = len(lines[line_n].split())

            if 'Started mdrun' in l:
                self.start = line_n
                # the line number that the simulation got started
                break


class REMDAnalysis(LogInfo):
    """
    A class for state-time analysis of replica exchange molecular dynamics simulations. When
    instantiating this class, one parameter (logfile) is required.
    """

    def __init__(self, logfile):
        """
        Sets up the properties of the instance of REMDAnalysis
        """
        self.sample_all = None
        self.finish = None   # if the simulation finishes all the steps specified
        self.n_ex = 0        # number of exchanges
        self.final_t = None
        LogInfo.__init__(self, logfile)

    def get_replica_data(self, logfile):
        """
        Gets the data of of each replica from the log file, including the state-time 
        data and transition matrix. Note that according to the log file in GROMACS, 
        index (i, j) in the transition matrix represents the number of exchanges 
        "BETWEEN SPOT i AND j" divided the total number of exchanges.

        Parameters
        ----------
        logfile : str
            The name of the log file to read.

        Returns
        -------
        transition_matrix : np.array
            The transition matrix.
        """

        f = open(logfile, 'r')
        lines = f.readlines()
        f.close()

        # Part 1: Get state-time data
        line_n = 0
        state_data = []
        for i in range(self.N_states):
            # data_all[i] represents the states that replica i has visited
            state_data.append([])
            state_data[i].append(i)

        for l in lines[self.start:]:
            line_n += 1
            if 'Order After Exchange' in l:
                self.n_ex += 1
                state_list = [int(i) for i in l.split(':')[1].split()]
                for i in range(self.N_states):
                    state_data[i].append(state_list.index(i))

        self.final_t = self.n_ex * self.replex * self.dt  # units: ps
        time = np.linspace(0, self.final_t, self.n_ex + 1)

        # Part 2: Get the data of transition matrix
        try:
            # Use external shell command to search the string would be faster
            subprocess.check_output("grep 'Replica exchange statistics' %s" % logfile, shell=True)
            self.finish = True
        except:
            # Handle the error which would occur if the string is not found
            self.finish = False

        line_n = 0
        count_matrix = np.zeros([self.N_states, self.N_states])
        transition_matrix = np.zeros([self.N_states, self.N_states])

        if self.finish is True:
            # Then read from the bottom to get the overlap matrix
            # (since if the simulation is finished, the overlap matrix will be calculated automatically)
            lines.reverse()    # from this point, lines has been reverse
            for l in lines:
                # print(l)    # this will print from the bottom
                line_n += 1
                if 'Replica exchange statistics' in l:
                    # data starts from lines[line_n - 5]
                    for i in range(self.N_states):
                        transition_matrix[i] = [float(v) for v in lines[line_n - 5 -
                                                                        i].split('Repl')[1].split()[:self.N_states]]

        if self.finish is False:
            # Then we have to calculate overlap matrix on our own as follows.
            for l in lines[self.start:]:  # skip the metadata
                line_n += 1
                if 'Accepted Exchanges' in l:
                    rep_list = [int(i) for i in l.split(':')[1].split()]
                    for i in rep_list:
                        # Note that for the diagnal: count_matrix[i, i] += 2
                        count_matrix[i, rep_list.index(i)] += 1
                        count_matrix[rep_list.index(i), i] += 1

            # get transition_matrix from the data of count_matrix
            for i in range(self.N_states):
                for j in range(self.N_states):
                    transition_matrix[i, j] = count_matrix[i, j] / sum(count_matrix[i])

        return time, state_data, transition_matrix

    def plot_state_data(self, time, state_data, png_name):
        if int(np.sqrt(self.N_states) + 0.5) ** 2 == self.N_states:
            # perfect sqaure number
            n_cols = int(np.sqrt(self.N_states))
        else:
            n_cols = int(np.floor(np.sqrt(self.N_states))) + 1

        if self.N_states % n_cols == 0:
            n_rows = int(self.N_states / n_cols)
        else:
            n_rows = int(np.floor(self.N_states / n_cols)) + 1

        _, ax = plt.subplots(nrows=n_rows, ncols=n_cols, figsize=(2.5 * n_cols, 2.5 * n_rows))
        plt.suptitle('Exploration of states as a function of time', weight='bold', fontsize=14)

        for i in range(self.N_states):
            plt.subplot(n_rows, n_cols, i + 1)
            plt.plot(np.array(time) / 1000, state_data[i])
            plt.annotate('(Replica %s)' % i, xy=(0, 0), xytext=(0, self.N_states * 0.05))

            if (i + 1) % n_cols == 1:
                plt.ylabel('State')
            if (i + 1) > (n_rows - 1) * n_cols:
                plt.xlabel('Time (ns)')

            plt.ylim([0, self.N_states - 1])
            plt.grid()

        # Remove redundant subplots
        n_rm = n_cols * n_rows - self.N_states
        for i in range(n_rm):
            ax.flat[-1 * (i + 1)].set_visible(False)

        plt.tight_layout(pad=5.0, w_pad=0.5, h_pad=2.0)
        plt.savefig(png_name, dpi=600)
        # plt.show()
    
    def plot_matrix(self, matrix, png_name):
        sns.set_context(rc={
        'family': 'sans-serif',
        'sans-serif': ['DejaVu Sans'],
        'size': 5
        })

        K = len(matrix)
        plt.figure(figsize=(K / 2, K / 2))
        annot_matrix = np.zeros([K, K])   # matrix for annotating values

        mask = []
        for i in range(K):
            mask.append([])
            for j in range(len(matrix[0])):
                if matrix[i][j] < 0.005:            
                    mask[-1].append(True)
                else:
                    mask[-1].append(False)

        for i in range(K):
            for j in range(K):
                annot_matrix[i, j] = round(matrix[i, j], 2)

        ax = sns.heatmap(matrix, cmap="YlGnBu", linecolor='silver', linewidth=0.25, 
                        annot=annot_matrix, square=True, mask=mask, fmt='.2f', cbar=False)
        ax.xaxis.tick_top()
        ax.tick_params(length=0)
        cmap = cm.get_cmap('YlGnBu')   # to get the facecolor
        ax.set_facecolor(cmap(0))      # use the brightest color (value = 0)
        for _, spine in ax.spines.items():
            spine.set_visible(True)    # add frames to the heat map
        plt.annotate('$\lambda$', xy=(0, 0), xytext=(-0.45, -0.20))
        plt.title('Transition matrix', fontsize=14, weight='bold')
        plt.tight_layout(pad=1.0)

        plt.savefig(png_name, dpi=600)
        # plt.show()


class MBARAnalysis(REMDAnalysis):
    """
    A class using MBAR to perform free energy calculations.
    """

    def __init__(self, logfile):
        """
        Sets up the properties of the instance of MBARAnalysis
        """
        LogInfo.__init__(self, logfile)
        REMDAnalysis.__init__(self, logfile)

    def decorrelate_data(self, start, end):
        K = self.N_states
        u_kln = np.zeros([K, K, max(end-start), np.float64])
        N_k = np.zeros(K, int)  # the number of uncorrelated samples from state k
        g = np.zeros(K, float)  # correlation times for the data
        










    def get_overlap_matrix():
        # this matrix can be obtained only if MBAR is used
        pass

        #f = open(log, 'r')
        #lines = f.readlines()
        # f.close()


def main():
    start = timer.time()

    rc('font', **{
        'family': 'sans-serif',
        'sans-serif': ['DejaVu Sans'],
        'size': 10
    })
    # Set the font used for MathJax - more on this later
    rc('mathtext', **{'default': 'regular'})
    plt.rc('font', family='serif')

    args = initialize()

    if args.log is None:
        for file in os.listdir('.'):
            if file.endswith('.log'):
                args.log = file
        if args.log is None:
            print('No log files provided or found! Please check if the dirctory is correct or specify the name of the log file.')
            sys.exit()

    if args.prefix is None:
        args.prefix = args.log.split('.')[0]

    result_str = '\nData analysis of the file %s:' % args.log
    print(result_str)
    print('=' * (len(result_str) - 1))  # len(result_str) includes \n 
    
    print('Analyzing the log file ...')
    RA = REMDAnalysis(args.log)
    time, state, t_matrix = RA.get_replica_data(args.log)
    print('Simulation length: %s ns (%s exchanges occured.)\n' % (RA.final_t / 1000, RA.n_ex))
    
    print('Plotting the exploration of states as a function of time ...')
    RA.plot_state_data(time, state, 'state_time_%s.png' % args.prefix)
    print('The state time plot, state_time_%s.png, has been geneated.\n' % args.prefix)

    print('Plotting the transition matrix as a heat map ...')
    RA.plot_matrix(t_matrix, 'transition_matrix_%s.png' % args.prefix)
    print('The heat map of the transition matrix, transition_matrix_%s.png, has been generated.\n' % args.prefix)

    end = timer.time()
    print('Total time elasped: %s seconds.\n' % (end - start))